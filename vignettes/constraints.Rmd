---
title: "Constraints in depth"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{constraints}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(easylp)
```

This vignette will teach you all the different ways to define linear constraints.

# Introduction

## Basics

Let's start with a problem with 2 scalar variables and we'll complicate it from there. Say our constraint is: $2x \le y$. We can write the constraint just like we would in pen and paper!

```{r}
lp <- easylp$new()
lp$var("x")
lp$var("y")
lp$con(2*x <= y)
```

As you can see, we don't need to put the variables on the left hand side and the constant on the right hand side. We don't need to expand the expression either. Say our next constraint is $x+3(y+1)\ge0$. We can write it just like that.

```{r}
lp$con(x + 3*(y + 1) >= 0)
#> Equivalent to
#> lp$con(x + 3*y + 3 >= 0)
```

Now we can define an equality constraint. And we'll name it, for good measure. Notice how the single equal `=` separates the name from the constraint, and the double equal `==` is used to represent equality. Just like base R.

```{r}
lp$con(last =  x + y == 4)
```

You may have seen linear constraints represented as $Ax\lesseqgtr b$. Easylp stores constraints in this way. You can see them using `lp$pretty_constraint` or, alternatively, `lp$constraint`.

```{r}
lp$pretty_constraints
#> The following would show how constraints are actually stored internally.
#> lp$constraint
```

## Vector Variables

In Easylp, variables can be scalars, vectors, or even multi-dimensional arrays. Take this example, where two different factories {A, B}, produce shirts and pants.

```{r}
factory <- c("A", "B")
lp <- easylp$new()
lp$var("shirts", factory, lower=0, integer=TRUE)
lp$var("pants",  factory, lower=0, integer=TRUE)
```

### Sums of variables

Say that we must produce at least 80 shirts and 50 pants between the two factories. These constraints can be represented as:

$$
\sum_{i\in F}{shirts_i} \ge 80
$$

$$
\sum_{i\in F}{pants_i} \ge 50
$$

This is one way to write them in Easylp.

```{r}
lp1 <- lp$clone()
lp1$con(
    shirt =  sum(shirts) >= 80,
    pant  =  sum(pants)  >= 50
)
```

We're told we need to produce a minimum of 200 products, between shirts and pants. Thanks to the awesome developer of Easylp, we can use `sum` with multiple arguments.

```{r}
lp1$con(total =  sum(shirts, pants) >= 200)
#> Equivalent to
#> lp1$con(total =  sum(shirts) + sum(pants) >= 200)

lp1$pretty_constraints
```

### Indexing

Variables can be indexed just like you would in R. It's possible to use numbers or names, if the variable has any. In this case, the names of the variables are {A, B}, because they're defined for each factory.

```{r}
lp1 <- lp$clone()
lp1$con(shirts[1] + pants["A"] <= 160)
lp1$pretty_constraints
```

### One line, multiple constraints

Take the following example: each factory must produce more shirts than pants.

$$
shirts_i \ge pants_i \ \ \forall i\in F
$$

Your first instinct may be to write something like this.

```{r}
lp1 <- lp$clone()
for (i in factory) {
    lp1$con(name =  shirts[i] >= pants[i])
}
```

And this would be correct! But Easylp allows you to write this in a more concise way, using the following syntax.

```{r}
lp2 <- lp$clone()
lp2$con(name =  for(i in factory) shirts[i] >= pants[i])
```

The third and last way to do this is to use vectorized operations, which is a common feature in R.

```{r}
lp3 <- lp$clone()
lp3$con(name =  shirts >= pants)
```

Notice the only difference between the three is how the constraints are named. My personal favorite is the second method, because it's shorter than the first, and more intuitive than the third.

```{r}
lp1$pretty_constraints
lp2$pretty_constraints
lp3$pretty_constraints
```

## Matrix Variables

Let's use a simple transportation problem as an example. We have two factories {A, B} sending products to two markets {1, 2}. The variable `t` represents products transported from each factory to each market.

```{r}
factory <- c("A", "B")
market <- c(1, 2)
lp <- easylp$new()
lp$var("t", factory, market, lower=0)
```

Each factory can produce up to a maximum `capacity`, and each market has a minimum `demand`.

$$
production_i = \sum_{j\in M}{t_{ij}}\le capacity_i \ \ \forall i\in F
$$

$$
stock_j=\sum_{i\in F}{t_{ij}}\ge demand_j \ \ \forall j\in M
$$

```{r}
capacity <- c(120, 180) |> setNames(factory)
demand <- c(140, 150)

lp$con(
    cap =  for(i in factory) sum(t[i, ]) <= capacity[i],
    dem =  for(j in market)  sum(t[, j]) >= demand[j]
)
lp$pretty_constraints
```

Another way to define these constraints is by using `sum_for`. This function is discussed in depth in `vignette("objective")`.

```{r}
lp$con(
    cap =  for(i in factory) sum_for(j=market,  t[i, j]) <= capacity[i],
    dem =  for(j in market)  sum_for(i=factory, t[i, j]) >= demand[j]
)
```

Notice how similar this syntax is to the one used in math.

$\dots, \forall a \in A \to$ `for(a in A) {...}`

$\sum_{b\in B}{(\dots)}\to$ `sum_for(b=B, ...)`

# Sensitivity

You can obtain sensitivity for right-hand-side coefficients after successfully solving a linear problem. Unfortunately, sensitivity is only available if there are no integer or binary variables.

```{r}
lp <- easylp$new()
lp$var("x", lower=0) # Red brass, 90% copper, 10% zinc.
lp$var("y", lower=0) # Silicon bronze, 82% copper, 14% zinc, 4% silicon.
lp$max(8*x + 6*y)
lp$con(
    copper  =  0.90*x + 0.64*y <= 120,
    zinc    =  0.10*x + 0.14*y <= 15,
    silicon =           0.04*y <= 2
)

lp$solve()
lp$sensitivity_rhs |> round()
```

Be aware! If constraints are defined with variables on the right-hand-side, the results may be unexpected. Internally, Easylp stores variables on the left-hand-side and constants on the right-hand-side. See how it handles the following example:

```{r}
lp <- easylp$new()
lp$var("x")
lp$con(2 >= x)
lp$pretty_constraints
```

# Removing Constraints

Removing constraints is a way to make a problem feasible. You can use `easylp$uncon()` to un-constraint a problem.

```{r}
lp <- easylp$new()
lp$var("x", 1:4)
lp$min(sum(x))
lp$con(
    all_lesser =  x <= 2,
    average    =  mean(x) >= 3
)
lp$solve()
lp$pretty_constraints
lp$status
```

All x must be lesser than 2, but the mean must be greater than 3. That's impossible! Let's try removing the first constraint.

```{r}
lp1 <- lp$clone()
lp1$uncon("all_lesser")
lp1$solve()
lp1$pretty_constraints
lp1$status
```

There's a couple things you should know about removing constraints:

-   You can only remove named constraints.

-   You cannot remove individual rows. For instance, you can't remove only `all_lesser[1]` from the previous example.

-   You can remove multiple constraints at once using a character vector. `lp$uncon(c("all_lesser", "average"))`
